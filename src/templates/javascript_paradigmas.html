{% extends "base.html" %}

{% block title %}{{ data.title }}{% endblock %}

{% block content %}
<div class="container">
    <div class="slide">
        <div class="slide-header">
            <h1 class="slide-title">{{ data.title }}</h1>
        </div>

        <div class="slide-content">
            <p>JavaScript √© uma linguagem de programa√ß√£o <strong>multiparadigma</strong> que suporta diferentes estilos de programa√ß√£o, desde programa√ß√£o imperativa e baseada em eventos at√© programa√ß√£o funcional e orientada a objetos (baseada em prot√≥tipos).</p>
        </div>

        <div class="paradigms-grid">
            {% for paradigm in data.paradigms %}
            <div class="paradigm-card">
                <div class="paradigm-name">{{ paradigm.name }}</div>
                <div class="paradigm-description">{{ paradigm.description }}</div>

                <h5 style="color: var(--primary-color); margin: 15px 0 10px 0;">Caracter√≠sticas:</h5>
                <ul class="paradigm-features">
                    {% for feature in paradigm.features %}
                    <li>{{ feature }}</li>
                    {% endfor %}
                </ul>
            </div>
            {% endfor %}
        </div>
    </div>

    <div class="slide">
        <div class="slide-header">
            <h2 class="slide-title">Exemplos Pr√°ticos dos Paradigmas</h2>
        </div>

        <div class="code-examples">
            <div class="code-example">
                <div class="code-header">Programa√ß√£o Baseada em Prot√≥tipos (OOP)</div>
                <div class="code-description">Heran√ßa protot√≠pica e objetos em JavaScript</div>
                <pre><code class="language-javascript">// Prot√≥tipo base
const Animal = {
    tipo: "Animal",
    fazerSom() {
        return `${this.nome} faz um som!`;
    }
};

// Cria√ß√£o de objeto com prot√≥tipo
const Cachorro = Object.create(Animal);
Cachorro.latir = function() {
    return `${this.nome} diz: Au au!`;
};

// Classes ES6+ (a√ß√∫car sint√°tico sobre prot√≥tipos)
class Gato {
    constructor(nome) {
        this.nome = nome;
    }

    miar() {
        return `${this.nome} diz: Miau!`;
    }

    // M√©todo est√°tico
    static √©Felino() {
        return true;
    }
}

// Heran√ßa com classes
class Tigre extends Gato {
    constructor(nome) {
        super(nome);
    }

    rugir() {
        return `${this.nome} diz: Grrrr!`;
    }
}

// Uso
const meuGato = new Gato("Mimi");
const meuTigre = new Tigre("Rajah");
console.log(meuGato.miar());
console.log(meuTigre.rugir());
console.log(Gato.√©Felino()); // true</code></pre>
            </div>

            <div class="code-example">
                <div class="code-header">Programa√ß√£o Funcional</div>
                <div class="code-description">Fun√ß√µes de primeira classe, closures e composi√ß√£o</div>
                <pre><code class="language-javascript">// Fun√ß√µes como cidad√£os de primeira classe
const dobrar = x => x * 2;
const somar = (a, b) => a + b;

// Fun√ß√µes de alta ordem
const aplicarOperacao = (array, operacao) => array.map(operacao);

// Closure
function criarContador() {
    let contador = 0;

    return function() {
        contador++;
        return contador;
    };
}

// Composi√ß√£o de fun√ß√µes
const compor = (f, g) => x => f(g(x));
const gritar = texto => texto.toUpperCase() + "!!!";
const exclamar = texto => texto + "!";

const gritarExclamar = compor(gritar, exclamar);
console.log(gritarExclamar("ol√°")); // "OL√Å!!!"

// Programa√ß√£o funcional com arrays
const numeros = [1, 2, 3, 4, 5];

// Map, Filter, Reduce
const quadrados = numeros.map(n => n * n);
const pares = numeros.filter(n => n % 2 === 0);
const soma = numeros.reduce((acc, n) => acc + n, 0);

console.log(quadrados, pares, soma);

// Imutabilidade (usando spread operator)
const pessoa = { nome: "Jo√£o", idade: 30 };
const pessoaAtualizada = { ...pessoa, idade: 31 };
console.log(pessoa, pessoaAtualizada); // Objetos diferentes</code></pre>
            </div>

            <div class="code-example">
                <div class="code-header">Programa√ß√£o Orientada a Eventos</div>
                <div class="code-description">Callbacks, Promises e async/await</div>
                <pre><code class="language-javascript">// Callbacks (estilo antigo)
function buscarDadosCallback(url, callback) {
    setTimeout(() => {
        callback({ data: `Dados de ${url}` });
    }, 1000);
}

buscarDadosCallback('/api/users', (resultado) => {
    console.log(resultado.data);
});

// Promises
function buscarDadosPromise(url) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (Math.random() > 0.1) {
                resolve({ data: `Dados de ${url}`, status: 200 });
            } else {
                reject(new Error('Falha na requisi√ß√£o'));
            }
        }, 1000);
    });
}

buscarDadosPromise('/api/posts')
    .then(data => console.log(data))
    .catch(error => console.error(error));

// Async/Await (ES2017+)
async function buscarTodosDados() {
    try {
        const [users, posts] = await Promise.all([
            buscarDadosPromise('/api/users'),
            buscarDadosPromise('/api/posts')
        ]);

        console.log('Usu√°rios:', users.data);
        console.log('Posts:', posts.data);

        return { users, posts };
    } catch (error) {
        console.error('Erro ao buscar dados:', error);
        throw error;
    }
}

// Event Listeners no DOM
document.addEventListener('DOMContentLoaded', () => {
    const botao = document.getElementById('meuBotao');

    botao.addEventListener('click', (evento) => {
        console.log('Bot√£o clicado!', evento.target);
        evento.preventDefault();

        // Atualizar UI assincronamente
        setTimeout(() => {
            botao.textContent = 'Clicado!';
        }, 500);
    });
});</code></pre>
            </div>
        </div>
    </div>

    <div class="slide">
        <div class="slide-header">
            <h2 class="slide-title">Flexibilidade Multiparadigma do JavaScript</h2>
        </div>

        <div class="slide-content">
            <p>A natureza multiparadigma do JavaScript permite que desenvolvedores:</p>

            <div class="key-points">
                <div class="key-point">
                    <h4>üîÑ Misturem Paradigmas</h4>
                    <p>Usem programa√ß√£o funcional para transforma√ß√£o de dados, orienta√ß√£o a eventos para UI, e OOP para organiza√ß√£o do c√≥digo, tudo no mesmo projeto.</p>
                </div>

                <div class="key-point">
                    <h4>üéØ Escolham o Melhor Abordagem</h4>
                    <p>Selecionem o paradigma mais apropriado para cada tarefa: funcional para pipelines de dados, baseada em eventos para interfaces, imperativa para scripts simples.</p>
                </div>

                <div class="key-point">
                    <h4>üìà Evoluam com as Vers√µes do ECMAScript</h4>
                    <p>Aproveitem as novas funcionalidades que expandem o suporte a diferentes paradigmas, como classes ES6, arrow functions, async/await, etc.</p>
                </div>

                <div class="key-point">
                    <h4>üåê Desenvolvam em M√∫ltiplos Ambientes</h4>
                    <p>Utilizem JavaScript no front-end (React/Vue), back-end (Node.js), mobile (React Native), e desktop (Electron) com os mesmos paradigmas.</p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}